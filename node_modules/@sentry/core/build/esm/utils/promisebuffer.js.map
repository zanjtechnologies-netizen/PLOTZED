{"version":3,"file":"promisebuffer.js","sources":["../../../src/utils/promisebuffer.ts"],"sourcesContent":["import { rejectedSyncPromise, resolvedSyncPromise } from './syncpromise';\n\nexport interface PromiseBuffer<T> {\n  // exposes the internal array so tests can assert on the state of it.\n  // XXX: this really should not be public api.\n  $: PromiseLike<T>[];\n  add(taskProducer: () => PromiseLike<T>): PromiseLike<T>;\n  drain(timeout?: number): PromiseLike<boolean>;\n}\n\nexport const SENTRY_BUFFER_FULL_ERROR = Symbol.for('SentryBufferFullError');\n\n/**\n * Creates an new PromiseBuffer object with the specified limit\n * @param limit max number of promises that can be stored in the buffer\n */\nexport function makePromiseBuffer<T>(limit: number = 100): PromiseBuffer<T> {\n  const buffer: Set<PromiseLike<T>> = new Set();\n\n  function isReady(): boolean {\n    return buffer.size < limit;\n  }\n\n  /**\n   * Remove a promise from the queue.\n   *\n   * @param task Can be any PromiseLike<T>\n   * @returns Removed promise.\n   */\n  function remove(task: PromiseLike<T>): void {\n    buffer.delete(task);\n  }\n\n  /**\n   * Add a promise (representing an in-flight action) to the queue, and set it to remove itself on fulfillment.\n   *\n   * @param taskProducer A function producing any PromiseLike<T>; In previous versions this used to be `task:\n   *        PromiseLike<T>`, but under that model, Promises were instantly created on the call-site and their executor\n   *        functions therefore ran immediately. Thus, even if the buffer was full, the action still happened. By\n   *        requiring the promise to be wrapped in a function, we can defer promise creation until after the buffer\n   *        limit check.\n   * @returns The original promise.\n   */\n  function add(taskProducer: () => PromiseLike<T>): PromiseLike<T> {\n    if (!isReady()) {\n      return rejectedSyncPromise(SENTRY_BUFFER_FULL_ERROR);\n    }\n\n    // start the task and add its promise to the queue\n    const task = taskProducer();\n    buffer.add(task);\n    void task.then(\n      () => remove(task),\n      () => remove(task),\n    );\n    return task;\n  }\n\n  /**\n   * Wait for all promises in the queue to resolve or for timeout to expire, whichever comes first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the queue is still non-empty. Passing `0` (or\n   * not passing anything) will make the promise wait as long as it takes for the queue to drain before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if the queue is already empty or drains before the timeout, and\n   * `false` otherwise\n   */\n  function drain(timeout?: number): PromiseLike<boolean> {\n    if (!buffer.size) {\n      return resolvedSyncPromise(true);\n    }\n\n    // We want to resolve even if one of the promises rejects\n    const drainPromise = Promise.allSettled(Array.from(buffer)).then(() => true);\n\n    if (!timeout) {\n      return drainPromise;\n    }\n\n    const promises = [drainPromise, new Promise<boolean>(resolve => setTimeout(() => resolve(false), timeout))];\n\n    // Promise.race will resolve to the first promise that resolves or rejects\n    // So if the drainPromise resolves, the timeout promise will be ignored\n    return Promise.race(promises);\n  }\n\n  return {\n    get $(): PromiseLike<T>[] {\n      return Array.from(buffer);\n    },\n    add,\n    drain,\n  };\n}\n"],"names":[],"mappings":";;AAUO,MAAM,2BAA2B,MAAM,CAAC,GAAG,CAAC,uBAAuB;;AAE1E;AACA;AACA;AACA;AACO,SAAS,iBAAiB,CAAI,KAAK,GAAW,GAAG,EAAoB;AAC5E,EAAE,MAAM,MAAM,GAAwB,IAAI,GAAG,EAAE;;AAE/C,EAAE,SAAS,OAAO,GAAY;AAC9B,IAAI,OAAO,MAAM,CAAC,IAAA,GAAO,KAAK;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,MAAM,CAAC,IAAI,EAAwB;AAC9C,IAAI,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,GAAG,CAAC,YAAY,EAAwC;AACnE,IAAI,IAAI,CAAC,OAAO,EAAE,EAAE;AACpB,MAAM,OAAO,mBAAmB,CAAC,wBAAwB,CAAC;AAC1D;;AAEA;AACA,IAAI,MAAM,IAAA,GAAO,YAAY,EAAE;AAC/B,IAAI,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC;AACpB,IAAI,KAAK,IAAI,CAAC,IAAI;AAClB,MAAM,MAAM,MAAM,CAAC,IAAI,CAAC;AACxB,MAAM,MAAM,MAAM,CAAC,IAAI,CAAC;AACxB,KAAK;AACL,IAAI,OAAO,IAAI;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,SAAS,KAAK,CAAC,OAAO,EAAiC;AACzD,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE;AACtB,MAAM,OAAO,mBAAmB,CAAC,IAAI,CAAC;AACtC;;AAEA;AACA,IAAI,MAAM,eAAe,OAAO,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,CAAC,MAAM,IAAI,CAAC;;AAEhF,IAAI,IAAI,CAAC,OAAO,EAAE;AAClB,MAAM,OAAO,YAAY;AACzB;;AAEA,IAAI,MAAM,QAAA,GAAW,CAAC,YAAY,EAAE,IAAI,OAAO,CAAU,OAAA,IAAW,UAAU,CAAC,MAAM,OAAO,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;;AAE/G;AACA;AACA,IAAI,OAAO,OAAO,CAAC,IAAI,CAAC,QAAQ,CAAC;AACjC;;AAEA,EAAE,OAAO;AACT,IAAI,IAAI,CAAC,GAAqB;AAC9B,MAAM,OAAO,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC;AAC/B,KAAK;AACL,IAAI,GAAG;AACP,IAAI,KAAK;AACT,GAAG;AACH;;;;"}