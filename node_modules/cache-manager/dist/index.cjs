"use strict";var R=Object.create;var T=Object.defineProperty;var K=Object.getOwnPropertyDescriptor;var j=Object.getOwnPropertyNames;var W=Object.getPrototypeOf,O=Object.prototype.hasOwnProperty;var $=(a,r)=>{for(var c in r)T(a,c,{get:r[c],enumerable:!0})},x=(a,r,c,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let u of j(r))!O.call(a,u)&&u!==c&&T(a,u,{get:()=>r[u],enumerable:!(s=K(r,u))||s.enumerable});return a};var V=(a,r,c)=>(c=a!=null?R(W(a)):{},x(r||!a||!a.__esModule?T(c,"default",{value:a,enumerable:!0}):c,a)),B=a=>x(T({},"__esModule",{value:!0}),a);var z={};$(z,{KeyvAdapter:()=>v,createCache:()=>L});module.exports=B(z);var _=V(require("events"),1),d=require("@cacheable/utils"),S=require("keyv");var v=class{opts;namespace;_cache;constructor(r){this._cache=r}async get(r){let c=await this._cache.get(r);if(c!=null)return c}async set(r,c,s){return await this._cache.set(r,c,s),!0}async delete(r){return await this._cache.del(r),!0}async clear(){return this._cache.reset?.()}async has(r){return!!await this._cache.get(r)}async getMany(r){return this._cache.mget(...r).then(c=>c.map(s=>s))}async deleteMany(r){return await this._cache.mdel(...r),!0}on(r,c){return this._cache.on?.(r,c),this}async disconnect(){await this._cache.disconnect?.()}};var b=a=>a===0?"primary":`secondary:${a-1}`,L=a=>{let r=new _.default,c=new S.Keyv;c.serialize=void 0,c.deserialize=void 0;let s=a?.stores?.length?a.stores:[c],u=a?.nonBlocking??!1,p=a?.cacheId??Math.random().toString(36).slice(2),A=async e=>{let t;if(u)try{if(t=await Promise.race(s.map(async n=>n.get(e))),t===void 0)return}catch(n){r.emit("get",{key:e,error:n})}else for(let n=0;n<s.length;n++){let i=s[n];try{let o=await i.get(e);if(o!==void 0){t=o,r.emit("get",{key:e,value:t,store:b(n)});break}}catch(o){r.emit("get",{key:e,error:o,store:b(n)})}}return t},C=async e=>{let t=e.map(()=>{});if(u)try{t=await Promise.race(s.map(async n=>n.getMany(e)))}catch(n){r.emit("mget",{keys:e,error:n})}else for(let n of s)try{let i=t.map((l,y)=>l===void 0?{originalIndex:y,key:e[y]}:void 0).filter(l=>l!==void 0);if(i.length===0)break;let o=i.map(l=>l.key),f=await n.getMany(o);for(let[l,y]of f.entries()){if(y===void 0)continue;let{originalIndex:P}=i[l];t[P]=y}}catch(i){r.emit("mget",{keys:e,error:i})}return r.emit("mget",{keys:e,values:t}),t},M=async e=>{let t;if(u)try{if(t=await Promise.race(s.map(async n=>n.get(e,{raw:!0}))),t===void 0)return}catch(n){r.emit("ttl",{key:e,error:n})}else for(let n of s)try{let i=await n.get(e,{raw:!0});if(i!==void 0){t=i,r.emit("ttl",{key:e,value:t});break}}catch(i){r.emit("ttl",{key:e,error:i})}if(t?.expires)return t.expires},h=async(e,t,n,i)=>{try{let o=e.map(async(f,l)=>{await f.set(t,n,i??a?.ttl),r.emit("set",{key:t,value:n,store:b(l)})});return u?(Promise.all(o),r.emit("set",{key:t,value:n}),n):(await Promise.all(o),r.emit("set",{key:t,value:n}),n)}catch(o){return r.emit("set",{key:t,value:n,error:o}),Promise.reject(o)}},D=async(e,t)=>{let n=t.map(({key:i,value:o,ttl:f})=>({key:i,value:o,ttl:f??a?.ttl}));try{let i=e.map(async o=>o.setMany(n));return u?(Promise.all(i),r.emit("mset",{list:n}),n):(await Promise.all(i),r.emit("mset",{list:n}),n)}catch(i){return r.emit("mset",{list:n,error:i}),Promise.reject(i)}};return{get:A,mget:C,ttl:M,set:async(e,t,n)=>h(s,e,t,n),mset:async e=>D(s,e),del:async e=>{try{return u?(Promise.all(s.map(async t=>t.delete(e))),r.emit("del",{key:e}),!0):(await Promise.all(s.map(async t=>t.delete(e))),r.emit("del",{key:e}),!0)}catch(t){return r.emit("del",{key:e,error:t}),Promise.reject(t)}},mdel:async e=>{try{let t=[];for(let n of e)t.push(...s.map(async i=>i.delete(n)));return u?(Promise.all(t),r.emit("mdel",{keys:e}),!0):(await Promise.all(t),r.emit("mdel",{keys:e}),!0)}catch(t){return r.emit("mdel",{keys:e,error:t}),Promise.reject(t)}},clear:async()=>{try{return u?(Promise.all(s.map(async e=>e.clear())),r.emit("clear"),!0):(await Promise.all(s.map(async e=>e.clear())),r.emit("clear"),!0)}catch(e){return r.emit("clear",e),Promise.reject(e)}},wrap:async(e,t,n,i)=>(0,d.coalesceAsync)(`${p}::${e}`,async()=>{let o,f,l=0,y,{ttl:P,refreshThreshold:I,raw:E}=(0,d.isObject)(n)?n:{ttl:n,refreshThreshold:i},w=m=>(0,d.runIfFn)(P,m)??a?.ttl;for(;l<s.length;l++)try{let m=await s[l].get(e,{raw:!0});if(m!==void 0){o=m.value,f=m,typeof m.expires=="number"&&(y=Math.max(0,m.expires-Date.now()));break}}catch{}if(o===void 0){let m=await t(),g=w(m);return await h(s,e,m,g),E?{value:m,expires:Date.now()+g}:m}let k=(0,d.lessThan)(y,(0,d.runIfFn)(I,o)??a?.refreshThreshold);return k&&(0,d.coalesceAsync)(`+++${p}__${e}`,t).then(async m=>{try{await h(a?.refreshAllStores?s:s.slice(0,l+1),e,m,w(m)),r.emit("refresh",{key:e,value:m})}catch(g){r.emit("refresh",{key:e,value:o,error:g})}}).catch(m=>{r.emit("refresh",{key:e,value:o,error:m})}),!k&&l>0&&await h(s.slice(0,l),e,o,w(o)),E?f:o}),on:(e,t)=>r.addListener(e,t),off:(e,t)=>r.removeListener(e,t),disconnect:async()=>{try{await Promise.all(s.map(async e=>e.disconnect()))}catch(e){return Promise.reject(e)}},cacheId:()=>p,stores:s}};0&&(module.exports={KeyvAdapter,createCache});
