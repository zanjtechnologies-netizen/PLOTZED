import M from"events";import{coalesceAsync as E,isObject as D,lessThan as I,runIfFn as k}from"@cacheable/utils";import{Keyv as R}from"keyv";var p=class{opts;namespace;_cache;constructor(t){this._cache=t}async get(t){let m=await this._cache.get(t);if(m!=null)return m}async set(t,m,s){return await this._cache.set(t,m,s),!0}async delete(t){return await this._cache.del(t),!0}async clear(){return this._cache.reset?.()}async has(t){return!!await this._cache.get(t)}async getMany(t){return this._cache.mget(...t).then(m=>m.map(s=>s))}async deleteMany(t){return await this._cache.mdel(...t),!0}on(t,m){return this._cache.on?.(t,m),this}async disconnect(){await this._cache.disconnect?.()}};var P=l=>l===0?"primary":`secondary:${l-1}`,H=l=>{let t=new M,m=new R;m.serialize=void 0,m.deserialize=void 0;let s=l?.stores?.length?l.stores:[m],u=l?.nonBlocking??!1,g=l?.cacheId??Math.random().toString(36).slice(2),x=async e=>{let r;if(u)try{if(r=await Promise.race(s.map(async n=>n.get(e))),r===void 0)return}catch(n){t.emit("get",{key:e,error:n})}else for(let n=0;n<s.length;n++){let a=s[n];try{let i=await a.get(e);if(i!==void 0){r=i,t.emit("get",{key:e,value:r,store:P(n)});break}}catch(i){t.emit("get",{key:e,error:i,store:P(n)})}}return r},_=async e=>{let r=e.map(()=>{});if(u)try{r=await Promise.race(s.map(async n=>n.getMany(e)))}catch(n){t.emit("mget",{keys:e,error:n})}else for(let n of s)try{let a=r.map((c,f)=>c===void 0?{originalIndex:f,key:e[f]}:void 0).filter(c=>c!==void 0);if(a.length===0)break;let i=a.map(c=>c.key),d=await n.getMany(i);for(let[c,f]of d.entries()){if(f===void 0)continue;let{originalIndex:T}=a[c];r[T]=f}}catch(a){t.emit("mget",{keys:e,error:a})}return t.emit("mget",{keys:e,values:r}),r},S=async e=>{let r;if(u)try{if(r=await Promise.race(s.map(async n=>n.get(e,{raw:!0}))),r===void 0)return}catch(n){t.emit("ttl",{key:e,error:n})}else for(let n of s)try{let a=await n.get(e,{raw:!0});if(a!==void 0){r=a,t.emit("ttl",{key:e,value:r});break}}catch(a){t.emit("ttl",{key:e,error:a})}if(r?.expires)return r.expires},y=async(e,r,n,a)=>{try{let i=e.map(async(d,c)=>{await d.set(r,n,a??l?.ttl),t.emit("set",{key:r,value:n,store:P(c)})});return u?(Promise.all(i),t.emit("set",{key:r,value:n}),n):(await Promise.all(i),t.emit("set",{key:r,value:n}),n)}catch(i){return t.emit("set",{key:r,value:n,error:i}),Promise.reject(i)}},A=async(e,r)=>{let n=r.map(({key:a,value:i,ttl:d})=>({key:a,value:i,ttl:d??l?.ttl}));try{let a=e.map(async i=>i.setMany(n));return u?(Promise.all(a),t.emit("mset",{list:n}),n):(await Promise.all(a),t.emit("mset",{list:n}),n)}catch(a){return t.emit("mset",{list:n,error:a}),Promise.reject(a)}};return{get:x,mget:_,ttl:S,set:async(e,r,n)=>y(s,e,r,n),mset:async e=>A(s,e),del:async e=>{try{return u?(Promise.all(s.map(async r=>r.delete(e))),t.emit("del",{key:e}),!0):(await Promise.all(s.map(async r=>r.delete(e))),t.emit("del",{key:e}),!0)}catch(r){return t.emit("del",{key:e,error:r}),Promise.reject(r)}},mdel:async e=>{try{let r=[];for(let n of e)r.push(...s.map(async a=>a.delete(n)));return u?(Promise.all(r),t.emit("mdel",{keys:e}),!0):(await Promise.all(r),t.emit("mdel",{keys:e}),!0)}catch(r){return t.emit("mdel",{keys:e,error:r}),Promise.reject(r)}},clear:async()=>{try{return u?(Promise.all(s.map(async e=>e.clear())),t.emit("clear"),!0):(await Promise.all(s.map(async e=>e.clear())),t.emit("clear"),!0)}catch(e){return t.emit("clear",e),Promise.reject(e)}},wrap:async(e,r,n,a)=>E(`${g}::${e}`,async()=>{let i,d,c=0,f,{ttl:T,refreshThreshold:C,raw:w}=D(n)?n:{ttl:n,refreshThreshold:a},v=o=>k(T,o)??l?.ttl;for(;c<s.length;c++)try{let o=await s[c].get(e,{raw:!0});if(o!==void 0){i=o.value,d=o,typeof o.expires=="number"&&(f=Math.max(0,o.expires-Date.now()));break}}catch{}if(i===void 0){let o=await r(),h=v(o);return await y(s,e,o,h),w?{value:o,expires:Date.now()+h}:o}let b=I(f,k(C,i)??l?.refreshThreshold);return b&&E(`+++${g}__${e}`,r).then(async o=>{try{await y(l?.refreshAllStores?s:s.slice(0,c+1),e,o,v(o)),t.emit("refresh",{key:e,value:o})}catch(h){t.emit("refresh",{key:e,value:i,error:h})}}).catch(o=>{t.emit("refresh",{key:e,value:i,error:o})}),!b&&c>0&&await y(s.slice(0,c),e,i,v(i)),w?d:i}),on:(e,r)=>t.addListener(e,r),off:(e,r)=>t.removeListener(e,r),disconnect:async()=>{try{await Promise.all(s.map(async e=>e.disconnect()))}catch(e){return Promise.reject(e)}},cacheId:()=>g,stores:s}};export{p as KeyvAdapter,H as createCache};
