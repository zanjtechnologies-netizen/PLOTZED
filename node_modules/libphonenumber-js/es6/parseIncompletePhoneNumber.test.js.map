{"version":3,"file":"parseIncompletePhoneNumber.test.js","names":["parseIncompletePhoneNumber","parsePhoneNumberCharacter","describe","it","expect","split","to","equal","be","undefined","stopped","emit","event","parsingEnded","eventListener","Error","concat"],"sources":["../source/parseIncompletePhoneNumber.test.js"],"sourcesContent":["import parseIncompletePhoneNumber, { parsePhoneNumberCharacter } from './parseIncompletePhoneNumber.js'\r\n\r\ndescribe('parseIncompletePhoneNumber', () => {\r\n\tit('should fix `for ... of` loop coverage', () => {\r\n\t\t// For some weird reason, \"istanbul\" doesn't know how to properly cover\r\n\t\t// a `for ... of` loop that has been transpiled with Babel.\r\n\t\t// For some reason, it attempts to cover the `for ... of` polyfill coode too,\r\n\t\t// meaning that it complains if that polyfill's edge case is not covered.\r\n\t\t// This test case works around that weird bug by covering that edge case of the polyfill.\r\n\t\t//\r\n\t\t// When it runs `npm test` command, it does so without `babel` transpilation,\r\n\t\t// so the error is gonna be \"string.split is not a function or its return value is not iterable\".\r\n\t\t//\r\n\t\t// When it runs `npm run test-coverage` command, it does so with `babel` transpilation,\r\n\t\t// so the error is gonna be \"Invalid attempt to iterate non-iterable instance.\".\r\n\t\t//\r\n\t\texpect(() => {\r\n\t\t\tparseIncompletePhoneNumber({\r\n\t\t\t\tsplit: () => 123\r\n\t\t\t})\r\n\t\t}).to.throw(/(not iterable|non-iterable)/)\r\n\t})\r\n\r\n\tit('should parse phone number character', () => {\r\n\t\t// Accepts leading `+`.\r\n\t\texpect(parsePhoneNumberCharacter('+')).to.equal('+')\r\n\r\n\t\t// Doesn't accept non-leading `+`.\r\n\t\texpect(parsePhoneNumberCharacter('+', '+')).to.be.undefined\r\n\r\n\t\t// Parses digits.\r\n\t\texpect(parsePhoneNumberCharacter('1')).to.equal('1')\r\n\r\n\t\t// Parses non-European digits.\r\n\t\texpect(parsePhoneNumberCharacter('٤')).to.equal('4')\r\n\r\n\t\t// Dismisses other characters.\r\n\t\texpect(parsePhoneNumberCharacter('-')).to.be.undefined\r\n\t})\r\n\r\n\tit('should parse incomplete phone number', () => {\r\n\t\texpect(parseIncompletePhoneNumber('')).to.equal('')\r\n\r\n\t\t// Doesn't accept non-leading `+`.\r\n\t\texpect(parseIncompletePhoneNumber('++')).to.equal('+')\r\n\r\n\t\t// Accepts leading `+`.\r\n\t\texpect(parseIncompletePhoneNumber('+7 800 555')).to.equal('+7800555')\r\n\r\n\t\t// Parses digits.\r\n\t\texpect(parseIncompletePhoneNumber('8 (800) 555')).to.equal('8800555')\r\n\r\n\t\t// Parses non-European digits.\r\n\t\texpect(parseIncompletePhoneNumber('+٤٤٢٣٢٣٢٣٤')).to.equal('+442323234')\r\n\t})\r\n\r\n\tit('should work with a new `context` argument in `parsePhoneNumberCharacter()` function (international number)', () => {\r\n\t\tlet stopped = false\r\n\r\n\t\tconst emit = (event) => {\r\n\t\t\tswitch (event) {\r\n\t\t\t\tcase 'end':\r\n\t\t\t\t\tstopped = true\r\n\t\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\texpect(parsePhoneNumberCharacter('+', undefined, emit)).to.equal('+')\r\n\t\texpect(stopped).to.equal(false)\r\n\r\n\t\texpect(parsePhoneNumberCharacter('1', '+', emit)).to.equal('1')\r\n\t\texpect(stopped).to.equal(false)\r\n\r\n\t\texpect(parsePhoneNumberCharacter('+', '+1', emit)).to.be.undefined\r\n\t\texpect(stopped).to.equal(true)\r\n\r\n\t\texpect(parsePhoneNumberCharacter('2', '+1', emit)).to.equal('2')\r\n\t\texpect(stopped).to.equal(true)\r\n\t})\r\n\r\n\tit('should work with a new `context` argument in `parsePhoneNumberCharacter()` function (national number)', () => {\r\n\t\tlet stopped = false\r\n\r\n\t\tconst emit = (event) => {\r\n\t\t\tswitch (event) {\r\n\t\t\t\tcase 'end':\r\n\t\t\t\t\tstopped = true\r\n\t\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\texpect(parsePhoneNumberCharacter('2', undefined, emit)).to.equal('2')\r\n\t\texpect(stopped).to.equal(false)\r\n\r\n\t\texpect(parsePhoneNumberCharacter('+', '2', emit)).to.be.undefined\r\n\t\texpect(stopped).to.equal(true)\r\n\r\n\t\texpect(parsePhoneNumberCharacter('1', '2', emit)).to.equal('1')\r\n\t\texpect(stopped).to.equal(true)\r\n\t})\r\n\r\n\tit('should call `eventListener` when the input ends abruptly', () => {\r\n\t\tlet parsingEnded = false\r\n\t\tconst eventListener = (event) => {\r\n\t\t\tparsingEnded = true;\r\n\t\t\tif (event !== 'end') {\r\n\t\t\t\tthrow new Error(`Unexpected event: ${event}`)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Doesn't accept non-leading `+`.\r\n\t\texpect(parsePhoneNumberCharacter('+', '+123', eventListener)).to.be.undefined\r\n\t\texpect(parsingEnded).to.equal(true)\r\n\t})\r\n})"],"mappings":"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","ignoreList":[]}